<pre>
<h4>51.有如下一段程序： </h4>
public class Test{
    private static int i=1;
    public int getNext(){
         return i++;
    }
    public static void main(String [] args){
        Test test=new Test();
        Test testObject=new Test();
        test.getNext();
        testObject.getNext();
        System.out.println(testObject.getNext());
    }
}
<h4>请问最后打印出来的是什么？（） </h4>

A.2

B.3

C.4

D.5

正确答案: B  
该题主要考察的是static属性和i++操作。
因为i是static的，是类属性，所以不管有多少对象，都共用的一个变量。这里getNext()方法被调用了三次，所以进行了三次i++操作。
但是由于getNext()操作的返回是：return i++; i++是先返回，后++，所以在println是，
已经返回了i(此时i为3)，再进行自增的，所以这里结果为3
</pre>
<PRE>
<H4>52.以下关于final关键字说法错误的是</H4>
A.final是java中的修饰符，可以修饰类、接口、抽象类、方法和属性

B.final修饰的类肯定不能被继承

C.final修饰的方法不能被重载

D.final修饰的变量不允许被再次赋值

正确答案: A C
inal修饰类、方法、属性！不能修饰抽象类，因为抽象类一般都是需要被继承的，final修饰后就不能继承了。
final修饰的方法不能被重写而不是重载！ 
final修饰属性，此属性就是一个常量，不能被再次赋值
</PRE>
<PRE>
<H4>53.下面叙述不正确的是（）</H4>
A.派生类一般都用公有派生

B.对基类成员的访问必须是无二义性的

C.赋值兼容规则也适用于多重继承的组合

D.父类的公有成员在派生类中仍然是公有的

正确答案: D
</PRE>
<PRE>
<H4>54.对下面Spring声明式事务的配置含义的说明错误的是（）</H4>
&lt;bean id="txProxyTemplate" abstract="true"
class=
"org.springframework.transaction.interceptor.TransactionProxyFactoryBean">
    &lt;property name="transactionManager" ref="myTransactionManager" />
&lt;property name="transactionAttributes">      
 &lt;props>
        &lt;prop key="get*">PROPAGATION_REQUIRED,readOnly</prop>
         &lt;prop key="*">PROPAGATION_REQUIRED</prop>
     &lt;/props>
&lt;/property> 
&lt;/bean>

A.定义了声明式事务的配置模板

B.对get方法采用只读事务

C.缺少sessionFactory属性的注入

D.配置需要事务管理的bean的代理时，通过parent引用这个配置模板，代码如下：
&lt;bean id="petBiz" parent="txProxyTemplate">
         <property name="target" ref="petTarget"/>
&lt;/bean>

正确答案: C 
&lt;!-- 配置事务管理器 --> 
      &lt;property name="transactionManager">
&lt;!-- 配置事务属性 --> 
      &lt;property name="transactionAttributes">      
  声明式事务 管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，
  在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，
  这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，
  便可以将事务规则应用到业务逻辑中。 
</PRE>

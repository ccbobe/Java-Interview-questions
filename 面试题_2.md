<pre>
<h4>51.有如下一段程序： </h4>
public class Test{
    private static int i=1;
    public int getNext(){
         return i++;
    }
    public static void main(String [] args){
        Test test=new Test();
        Test testObject=new Test();
        test.getNext();
        testObject.getNext();
        System.out.println(testObject.getNext());
    }
}
<h4>请问最后打印出来的是什么？（） </h4>

A.2

B.3

C.4

D.5

正确答案: B  
该题主要考察的是static属性和i++操作。
因为i是static的，是类属性，所以不管有多少对象，都共用的一个变量。这里getNext()方法被调用了三次，所以进行了三次i++操作。
但是由于getNext()操作的返回是：return i++; i++是先返回，后++，所以在println是，
已经返回了i(此时i为3)，再进行自增的，所以这里结果为3
</pre>
<PRE>
<H4>52.以下关于final关键字说法错误的是</H4>
A.final是java中的修饰符，可以修饰类、接口、抽象类、方法和属性

B.final修饰的类肯定不能被继承

C.final修饰的方法不能被重载

D.final修饰的变量不允许被再次赋值

正确答案: A C
inal修饰类、方法、属性！不能修饰抽象类，因为抽象类一般都是需要被继承的，final修饰后就不能继承了。
final修饰的方法不能被重写而不是重载！ 
final修饰属性，此属性就是一个常量，不能被再次赋值
</PRE>
<PRE>
<H4>53.下面叙述不正确的是（）</H4>
A.派生类一般都用公有派生

B.对基类成员的访问必须是无二义性的

C.赋值兼容规则也适用于多重继承的组合

D.父类的公有成员在派生类中仍然是公有的

正确答案: D
</PRE>
<PRE>
<H4>54.对下面Spring声明式事务的配置含义的说明错误的是（）</H4>
&lt;bean id="txProxyTemplate" abstract="true"
class=
"org.springframework.transaction.interceptor.TransactionProxyFactoryBean">
    &lt;property name="transactionManager" ref="myTransactionManager" />
&lt;property name="transactionAttributes">      
 &lt;props>
        &lt;prop key="get*">PROPAGATION_REQUIRED,readOnly</prop>
         &lt;prop key="*">PROPAGATION_REQUIRED</prop>
     &lt;/props>
&lt;/property> 
&lt;/bean>

A.定义了声明式事务的配置模板

B.对get方法采用只读事务

C.缺少sessionFactory属性的注入

D.配置需要事务管理的bean的代理时，通过parent引用这个配置模板，代码如下：
&lt;bean id="petBiz" parent="txProxyTemplate">
         &lt;property name="target" ref="petTarget"/>
&lt;/bean>

正确答案: C 
&lt;!-- 配置事务管理器 --> 
      &lt;property name="transactionManager">
&lt;!-- 配置事务属性 --> 
      &lt;property name="transactionAttributes">      
  声明式事务 管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，
  在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，
  这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，
  便可以将事务规则应用到业务逻辑中。 
</PRE>
<pre>
<h4>55.针对以下代码，哪些说法是正确的：（） </h4>
class CompareReference{
   public static void main(String [] args){
   float f=42.0f;
   float f1[]=new float[2];
   float f2[]=new float[2];
   float[] f3=f1;
   long x=42;
   f1[0]=42.0f;
  }
}

A.f1==f2

B.x==f1[0]

C.f1==f3

D.f2==f1[1]

正确答案: B C 
两个数值进行二元操作时，会有如下的转换操作：
如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。
否则，如果其中一个操作数是float类型，另一个将会转换为float类型。
否则，如果其中一个操作数是long类型，另一个会转换为long类型。
否则，两个操作数都转换为int类型。
故:x==f1[0]中，x将会转换为float类型。 
</pre>
<PRE>
<H4>56.以下描述正确的是</H4>
A.CallableStatement是PreparedStatement的父接口

B.PreparedStatement是CallableStatement的父接口

C.CallableStatement是Statement的子接口

D.PreparedStatement是Statement的父接口

正确答案: B 
</PRE>
<PRE>
<H4>57.关于ThreadLocal以下说法正确的是(多选)</H4>
A.ThreadLocal继承自Thread

B.ThreadLocal实现了Runnable接口

C.ThreadLocal重要作用在于多线程间的数据共享

D.ThreadLocal是采用哈希表的方式来为每个线程都提供一个变量的副本

E.ThreadLocal保证各个线程间数据安全，每个线程的数据不会被另外线程访问和破坏

正确答案: D E  
</PRE>
<pre>
<h4>58.以下哪一个不是赋值符号？</h4>
A.+=

B.&lt;&lt;=

C.&lt;&lt;&lt;=

D.>>>=

正确答案: C  
&lt;&lt;表示左移位
>>表示带符号右移位
>>>表示无符号右移
但是没有&lt;&lt;&lt;运算符 
</pre>
<PRE>
<H4>59.下列关于Java并发的说法中正确的是（）</H4>
A.CopyOnWriteArrayList适用于写多读少的并发场景

B.ReadWriteLock适用于读多写少的并发场景

C.ConcurrentHashMap的写操作不需要加锁，读操作需要加锁

D.只要在定义int类型的成员变量i的时候加上volatile关键字，那么多线程并发执行i++这样的操作的时候就是线程安全的了

正确答案: B   
A，CopyOnWriteArrayList适用于写少读多的并发场景
B，ReadWriteLock即为读写锁，他要求写与写之间互斥，读与写之间互斥，
读与读之间可以并发执行。在读多写少的情况下可以提高效率
C，ConcurrentHashMap是同步的HashMap，读写都加锁
D，volatile只保证多线程操作的可见性，不保证原子性 
</PRE>
<pre>
<h4>60.JDK提供的用于并发编程的同步器有哪些？(多选)</h4>
A.Semaphore

B.CyclicBarrier

C.CountDownLatch

D.Counter

正确答案: A B C 
</pre>
<pre>
<h4>61.有关线程的叙述正确的是()(多选)</h4>
A.可以获得对任何对象的互斥锁定

B.通过继承Thread类或实现Runnable接口，可以获得对类中方法的互斥锁定

C.线程通过调用对象的synchronized方法可获得对象的互斥锁定

D.线程调度算法是平台独立的

正确答案: C D
</pre>
<pre>
<h4>62.以下哪些类是线程安全的（）(多选)</h4>
A.Vector

B.HashMap

C.ArrayList

D.StringBuffer

E.Properties

正确答案: A D E
A，Vector相当于一个线程安全的List
B，HashMap是非线程安全的，其对应的线程安全类是HashTable
C，Arraylist是非线程安全的，其对应的线程安全类是Vector
D，StringBuffer是线程安全的，相当于一个线程安全的StringBuilder
E，Properties实现了Map接口，是线程安全的 
</pre>
<pre>
<h4>63.下面有关JAVA swing的描述，说法错误的是？</h4>
A.Swing是一个基于Java的跨平台MVC框架。使用单线程模式。

B.Swing 是为了解决 AWT 存在的问题而新开发的包，它以 AWT 为基础的

C.Swing优化了AWT，运行速度比AWT快

D.Swing是一个基于组件的框架，所有的组件都是从javax.swing.JComponent类继承来的

正确答案: C
Swing 是在AWT的基础上构建的一套新的图形界面系统，它提供了AWT 所能够提供的所有功能，
并且用纯粹的Java代码对AWT 的功能进行了大幅度的扩充。AWT 是基于本地方法的C/C++程序，
其运行速度比较快；Swing是基于AWT 的Java程序，其运行速度比较慢。
</pre>
<PRE>
<H4>64.下列正确的有（ ）(多选)</H4>
A.call by value不会改变实际参数的数值

B.call by reference能改变实际参数的参考地址

C.call by reference不能改变实际参数的参考地址

D.call by reference能改变实际参数的内容

正确答案: A C D
1 基本类型和基本类型变量被当作参数传递给方法时，是值传递。
在方法实体中，无法给原变量重新赋值，也无法改变它的值。
2 对象和引用型变量被当作参数传递给方法时，是引用传递。
在方法实体中，无法给原变量重新赋值，但是可以改变它所指向对象的属性。 
</PRE>
<pre>
<h4>65.Java程序的种类有（ ）(多选)</h4>
A.类（Class）

B.Applet

C.Application

D.Servlet

正确答案: B C D 
</pre>
<PRE>
<H4>66.class A {}
class B extends A {}
class C extends A {}
class D extends B {}
Which four statements are true ?(多选)</H4>
A.The type List&lt;A>is assignable to List.

B.The type List&lt;B>is assignable to List&lt;A>.

C.The type List&lt;Object>is assignable to List&lt;?>.

D.The type List&lt;D>is assignable to List&lt;?extends B>.

E.The type List&lt;?extends A>is assignable to List&lt;A>.

F.The type List&lt;Object>is assignable to any List reference.

G.The type List&lt;?extends B>is assignable to List&lt;?extends A>.

正确答案: A C D G
</PRE>
<pre>
<h4>67.java socket如何获取本地ip地址？</h4>
A.getInetAddress()

B.getLocalAddress()

C.getReuseAddress()

D.getLocalPort()

正确答案: B
</pre>
<pre>
<h4>68.如何获取ServletContext设置的参数值？</h4>
A.context.getParameter()

B.context.getInitParameter()

C.context.getAttribute()

D.context.getRequestDispatcher()

正确答案: B
</pre>
<PRE>
<H4>69.下列哪项不属于jdk1.6垃圾收集器？</H4>
A.Serail收集器

B.parNew收集器

C.CMS收集器

D.G1收集器

正确答案: D 
</PRE>

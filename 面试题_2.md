<pre>
<h4>51.有如下一段程序： </h4>
public class Test{
    private static int i=1;
    public int getNext(){
         return i++;
    }
    public static void main(String [] args){
        Test test=new Test();
        Test testObject=new Test();
        test.getNext();
        testObject.getNext();
        System.out.println(testObject.getNext());
    }
}
<h4>请问最后打印出来的是什么？（） </h4>

A.2

B.3

C.4

D.5

正确答案: B  
该题主要考察的是static属性和i++操作。
因为i是static的，是类属性，所以不管有多少对象，都共用的一个变量。这里getNext()方法被调用了三次，所以进行了三次i++操作。
但是由于getNext()操作的返回是：return i++; i++是先返回，后++，所以在println是，
已经返回了i(此时i为3)，再进行自增的，所以这里结果为3
</pre>
<PRE>
<H4>52.以下关于final关键字说法错误的是</H4>
A.final是java中的修饰符，可以修饰类、接口、抽象类、方法和属性

B.final修饰的类肯定不能被继承

C.final修饰的方法不能被重载

D.final修饰的变量不允许被再次赋值

正确答案: A C
inal修饰类、方法、属性！不能修饰抽象类，因为抽象类一般都是需要被继承的，final修饰后就不能继承了。
final修饰的方法不能被重写而不是重载！ 
final修饰属性，此属性就是一个常量，不能被再次赋值
</PRE>
<PRE>
<H4>53.下面叙述不正确的是（）</H4>
A.派生类一般都用公有派生

B.对基类成员的访问必须是无二义性的

C.赋值兼容规则也适用于多重继承的组合

D.父类的公有成员在派生类中仍然是公有的

正确答案: D
</PRE>
<PRE>
<H4>54.对下面Spring声明式事务的配置含义的说明错误的是（）</H4>
&lt;bean id="txProxyTemplate" abstract="true"
class=
"org.springframework.transaction.interceptor.TransactionProxyFactoryBean">
    &lt;property name="transactionManager" ref="myTransactionManager" />
&lt;property name="transactionAttributes">      
 &lt;props>
        &lt;prop key="get*">PROPAGATION_REQUIRED,readOnly</prop>
         &lt;prop key="*">PROPAGATION_REQUIRED</prop>
     &lt;/props>
&lt;/property> 
&lt;/bean>

A.定义了声明式事务的配置模板

B.对get方法采用只读事务

C.缺少sessionFactory属性的注入

D.配置需要事务管理的bean的代理时，通过parent引用这个配置模板，代码如下：
&lt;bean id="petBiz" parent="txProxyTemplate">
         &lt;property name="target" ref="petTarget"/>
&lt;/bean>

正确答案: C 
&lt;!-- 配置事务管理器 --> 
      &lt;property name="transactionManager">
&lt;!-- 配置事务属性 --> 
      &lt;property name="transactionAttributes">      
  声明式事务 管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，
  在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，
  这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，
  便可以将事务规则应用到业务逻辑中。 
</PRE>
<pre>
<h4>55.针对以下代码，哪些说法是正确的：（） </h4>
class CompareReference{
   public static void main(String [] args){
   float f=42.0f;
   float f1[]=new float[2];
   float f2[]=new float[2];
   float[] f3=f1;
   long x=42;
   f1[0]=42.0f;
  }
}

A.f1==f2

B.x==f1[0]

C.f1==f3

D.f2==f1[1]

正确答案: B C 
两个数值进行二元操作时，会有如下的转换操作：
如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。
否则，如果其中一个操作数是float类型，另一个将会转换为float类型。
否则，如果其中一个操作数是long类型，另一个会转换为long类型。
否则，两个操作数都转换为int类型。
故:x==f1[0]中，x将会转换为float类型。 
</pre>
<PRE>
<H4>56.以下描述正确的是</H4>
A.CallableStatement是PreparedStatement的父接口

B.PreparedStatement是CallableStatement的父接口

C.CallableStatement是Statement的子接口

D.PreparedStatement是Statement的父接口

正确答案: B 
</PRE>
<PRE>
<H4>57.关于ThreadLocal以下说法正确的是(多选)</H4>
A.ThreadLocal继承自Thread

B.ThreadLocal实现了Runnable接口

C.ThreadLocal重要作用在于多线程间的数据共享

D.ThreadLocal是采用哈希表的方式来为每个线程都提供一个变量的副本

E.ThreadLocal保证各个线程间数据安全，每个线程的数据不会被另外线程访问和破坏

正确答案: D E  
</PRE>
